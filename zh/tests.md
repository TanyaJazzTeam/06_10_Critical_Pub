
[这些是在 TensorFlow 存储库中](https://github.com/tensorflow/tensorflow)测试代码的推荐做法。

## 在开始之前

在向 TensorFlow 项目贡献源代码之前，请查看项目的 GitHub 存储库中的`CONTRIBUTING.md` （例如，查看 [核心 TensorFlow 存储库](https://github.com/tensorflow/tensorflow/blob/master/CONTRIBUTING.md)的 CONTRIBUTING.md 文件。）所有代码贡献者都必须签署[贡献者许可协议](https://cla.developers.google.com/clas)(CLA)。

## 一般原则

### 仅取决于您在 BUILD 规则中使用的内容

TensorFlow 是一个大型库，在为其子模块编写单元测试时依赖于完整包已成为一种常见做法。但是，这会禁用基于`bazel`依赖项的分析。这意味着持续集成系统无法智能地消除提交前/提交后运行的无关测试。如果您只依赖于您在`BUILD`文件中测试的子模块，您将为所有 TensorFlow 开发人员节省时间，并节省大量宝贵的计算能力。

但是，修改构建依赖项以省略完整的 TF 目标会为可以在 Python 代码中导入的内容带来一些限制。您将无法再在单元测试中`import tensorflow as tf`但这是一个值得的权衡，因为它使所有开发人员免于运行数千个不必要的测试。

### 所有代码都应该有单元测试

对于您编写的任何代码，您还应该编写其单元测试。如果你写了一个新文件`foo.py` ，你应该把它的单元测试放在`foo_test.py`并在相同的更改中提交它。目标是所有代码的增量测试覆盖率超过 90%。

### 避免在 TF 中使用原生 bazel 测试规则

TF 在运行测试时有很多微妙之处。我们一直在努力在 bazel 宏中隐藏所有这些复杂性。为避免处理这些，请使用以下而不是本机测试规则。请注意，所有这些都在`tensorflow/tensorflow.bzl`中定义，对于 CC 测试，请使用`tf_cc_test` 、 `tf_gpu_cc_test` 、 `tf_gpu_only_cc_test` 。对于 python 测试，请使用`tf_py_test`或`gpu_py_test` 。如果您需要一些非常接近本机`py_test`规则的内容，请改用 tensorflow.bzl 中定义的规则。您只需要在 BUILD 文件的顶部添加以下行： `load(“tensorflow/tensorflow.bzl”, “py_test”)`

### 注意测试执行的位置

当您编写测试时，我们的测试基础架构可以负责在 CPU、GPU 和加速器上运行您的测试（如果您相应地编写它们）。我们有在 Linux、macos、windows 上运行的自动化测试，这些测试有带或不带 GPU 的系统。您只需选择上面列出的宏之一，然后使用标签来限制它们的执行位置。

- `manual`标记将排除您的测试在任何地方运行。这包括使用模式的手动测试执行，例如`bazel test tensorflow/…`

- `no_oss`将排除您的测试在官方 TF OSS 测试基础架构中运行。

- `no_mac`或`no_windows`标签可用于从相关操作系统测试套件中排除您的测试。

- `no_gpu`标签可用于排除您的测试在 GPU 测试套件中运行。

### 验证测试在预期的测试套件中运行

TF 有很多测试套件。有时，它们的设置可能会令人困惑。可能有不同的问题导致您的测试从连续构建中被忽略。因此，您应该验证您的测试是否按预期执行。去做这个：

- 等待您对拉取请求（PR）的预提交运行完成。
- 滚动到 PR 底部以查看状态检查。
- 单击任何 Kokoro 检查右侧的“详细信息”链接。
- 检查“目标”列表以查找新添加的目标。

### 每个类/单元都应该有自己的单元测试文件

单独的测试类帮助我们更好地隔离故障和资源。它们导致更短且更易于阅读的测试文件。因此，你所有的 Python 文件都应该至少有一个对应的测试文件（对于每个`foo.py` ，它应该有`foo_test.py` ）。对于更复杂的测试，例如需要不同设置的集成测试，可以添加更多测试文件。

## 速度和运行时间

### 应该尽可能少地使用分片

请考虑：

- 使您的测试更小
- 如果上述方法不可行，请将测试拆分

分片有助于减少测试的整体延迟，但同样可以通过将测试分解为更小的目标来实现。拆分测试为我们提供了对每个测试的更精细控制，最大限度地减少了不必要的预提交运行，并减少了由于测试用例行为不当而导致 buildcop 禁用整个目标的覆盖率损失。此外，分片会产生不那么明显的隐藏成本，例如为所有分片运行所有测试初始化代码。基础设施团队已将此问题作为造成额外负载的来源上报给我们。

### 较小的测试更好

你的测试运行得越快，人们就越有可能运行你的测试。为您的测试多花一秒时间，可能会累积成开发人员和我们的基础设施花费数小时运行测试的额外时间。尝试让您的测试在 30 秒内运行（在非选择模式下！），并使它们变小。仅将您的测试标记为中等作为最后的手段。 Infra 不会在提交前或提交后运行任何大型测试！因此，如果您要安排它的运行位置，请只编写一个大型测试。使测试运行得更快的一些技巧：

- 在测试中运行较少的训练迭代
- 考虑使用依赖注入将被测系统的重依赖替换为简单的伪造。
- 考虑在单元测试中使用较小的输入数据
- 如果没有其他效果，请尝试拆分您的测试文件。

### 测试时间应针对测试大小超时的一半以避免剥落

对于`bazel`测试目标，小型测试有 1 分钟的超时时间。中等测试超时为 5 分钟。 TensorFlow 测试基础不执行大型测试。但是，许多测试所花费的时间并不是确定性的。由于各种原因，您的测试可能会时不时地花费更多时间。而且，如果你将一个平均运行 50 秒的测试标记为小，那么如果它在具有旧 CPU 的机器上调度，你的测试就会失败。因此，小型测试的目标平均运行时间为 30 秒。中等测试的平均运行时间为 2 分 30 秒。

### 减少样本数量并增加训练容差

缓慢运行的测试会阻止贡献者。在测试中运行训练可能非常慢。更喜欢更高的容差，以便能够在测试中使用更少的样本，以保持测试足够快（最多 2.5 分钟）。

## 消除不确定性和碎片

### 编写确定性测试

单元测试应该始终是确定性的。如果没有影响它们的代码更改，则在 TAP 和吉他上运行的所有测试每次都应该以相同的方式运行。为确保这一点，需要考虑以下几点。

### 始终播种任何随机性来源

任何随机数生成器或任何其他随机性来源都可能导致片状。因此，这些中的每一个都必须播种。除了使测试不那么不稳定之外，这还使所有测试都具有可重复性。设置一些您可能需要在 TF 测试中设置的种子的不同方法是：

```python
# Python RNG
import random
random.seed(42)

# Numpy RNG
import numpy as np
np.random.seed(42)

# TF RNG
from tensorflow.python.framework import random_seed
random_seed.set_seed(42)
```

### 避免在多线程测试中`sleep`

在测试中使用`sleep`功能可能是导致片状的主要原因。特别是在使用多线程时，使用 sleep 等待另一个线程永远不会是确定性的。这是因为系统无法保证不同线程或进程的执行顺序。因此，更喜欢确定性同步构造，例如互斥锁。

### 检查测试是否片状

薄片会导致构建警察和开发人员损失很多时间。它们很难检测，也很难调试。即使有自动系统来检测片状，他们也需要积累数百次测试运行才能准确地拒绝测试。即使他们检测到，他们也会拒绝您的测试并且测试覆盖率会丢失。因此，测试作者在编写测试时应该检查他们的测试是否不稳定。这可以通过使用以下标志运行测试轻松完成：-- `--runs_per_test=1000`

### 使用 TensorFlowTestCase

TensorFlowTestCase 采取了必要的预防措施，例如为所有用于减少片状性的随机数生成器播种。随着我们发现并修复更多的片状源，这些都将被添加到 TensorFlowTestCase。因此，在为 tensorflow 编写测试时应该使用 TensorFlowTestCase。 TensorFlowTestCase 在这里定义： `tensorflow/python/framework/test_util.py`

### 编写密封测试

密封测试不需要任何外部资源。他们装满了他们需要的一切，他们只是开始他们可能需要的任何虚假服务。除了您的测试之外的任何服务都是不确定性的来源。即使其他服务的可用性为 99%，网络也可能会出现故障，rpc 响应可能会延迟，并且您最终可能会收到莫名其妙的错误消息。外部服务可能是但不限于 GCS、S3 或任何网站。
